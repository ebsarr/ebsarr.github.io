<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

        
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu|Ubuntu+Mono" rel="stylesheet"> 

        <title>Introducing petitdb</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>
    <body>
      <div class="container-fluid">
        <nav class="navbar navbar-expand-md navbar-light">

          
          <span class="navbar-brand mb-0 h1"></span>

          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle Navigation" name="button">
            <span class="navbar-toggler-icon"></span>
          </button>

          <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
              <a class="nav-item nav-link " href="/">Home</a>
              
              
              <a class="nav-item nav-link " href="/about/">About</a>
            </div>
          </div>
        </nav>

        <section id="page-title">
          <h1><a href="/">btaars.net</a></h1>
          <span id="author-name">
            <h6><a href="/about/"></a></h6>
          </span>
        </section>


<div class="blog-post">
  <h1>Introducing petitdb</h1>
  <div class="blog-post-subheader">
    <time>26 Mar 2018</time>
  </div>
  <div class="blog-post-content">
    

<h1 id="what-is-petitdb">What is petitdb</h1>

<p><a href="https://github.com/ebsarr/petitdb.git"><code>petitdb</code></a> is a python library that I created a few years ago. As you can guess by the name, it&rsquo;s a library that provides some basic database functionnalities. Under the hood it&rsquo;s just operating on shelves, inside which dicts of dicts are created. Each dict in the shelve is presented as a table, and inside each dict resides another dict that stores key/value pairs.</p>

<h1 id="use-cases">Use cases</h1>

<p>One way I used this library was to store some configurations, mainly hostnames and some others attributes that go with it. For example, a <code>Host</code> object definition that looked like this in the main script:</p>

<pre><code class="language-python">class Host:
    &quot;&quot;&quot;Define a Host object
    A host object has the following  attributes:
      hostname, ip address, password, system name, node name
    &quot;&quot;&quot;
    def __init__(self, hostname, ip, passwd, system, node, login_user):
        self.hostname = hostname
        self.ip = ip
        self.login_user = login_user
        self.password = passwd
        self.system = system
        self.node = node

    def __str__(self):
        return \
            &quot;{0:s}\t=&gt;\t{1:&lt;15s}\t{2:&lt;20s}\t{3:&lt;20s}\t{4:&lt;7s}\t{5:&lt;7s}&quot;.format(
                self.hostname, self.ip, self.login_user, 'password',
                self.system, self.node)
</code></pre>

<p>I could store the attributes in a csv file, and everytime the script boots, read and parse the csv, initialize a <code>Host</code> object with every record. The problem I faced with this approach was: if somebody misconfigured the csv file, on the next boot the error could lead to the script not running properly. Using <code>petitdb</code>, I can easily separate the parsing of the configuration file, and the actual processing of the main script. That is, build a function that&rsquo;s purpose is only to read and parse the csv file, store the objects in a shelve using <code>petitdb</code>, and the main script itself would only have to read the configurations from <code>petitdb</code>, not a csv file. In this way I could ensure that when the script runs, it only reads configurations that are already validated and ready to use. OTOH, if the function that reads and parses the csv file(the configuration file) generates any error, the user knows right away that there is something wrong with csv.
<br><br>
As <code>petit</code> also provide some convenient methods to update objects, it was quite usefull when counting logs as well. For example, To count records based on the log type and datetime, it&rsquo;s usefull to store the counts in a dict while reading the log records one by one.
<br>
The data structure could look like this:</p>

<pre><code class="language-python"># To count errors in the syslog during a certain period of time.
counter['sys_log_errors'][datetime] = 1
</code></pre>

<p>Instead of directly manipulating dicts like this, I used <code>petitdb</code>, as it makes incremental operations very convenient with the <code>db.add()</code> method. Example:</p>

<pre><code class="language-python"># Using dicts, this is how we would increment:
counter['sys_log_errors']['datetime_string'] += 1
# But in case &quot;counter&quot; is shelve, this would not work, we'd need to retrieve the value first
current_value = counter['sys_log_errors'][datetime]
new_value = current_value + 1
counter['sys_log_errors']['datetime_string'] = new_value

# Using &quot;petit_db&quot;, incrementing is as simple as:
db.add('sys_log_errors', 'datetime_string', 1)
</code></pre>

<h1 id="using-petitdb">Using <code>petitdb</code></h1>

<h2 id="installation">Installation</h2>

<p>The tool is just one python file that you could store and import locally inside your script.
<br>
You can download it from github:</p>

<pre><code class="language-sh">$ git clone https://github.com/ebsarr/petitdb.git
</code></pre>

<p>And copy the <code>petitdb.py</code> in a place where your script could import it.</p>

<h2 id="features">Features</h2>

<p><code>petitdb</code> provides two classes:</p>

<ul>
<li><code>SmallDB</code>: provides an easy interface to shelves. You can store and retreive any object on dicts.</li>
<li><code>MemDB</code>: as subclass of <code>SmallDB</code> with no access to shelves, that is everything you do stays in memory.</li>
</ul>

<p><br>
Data manipulation on a <code>SmallDB</code> or <code>MemDB</code> instance can be done through the following methods:</p>

<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>insert</td>
<td>insert records</td>
</tr>

<tr>
<td>update</td>
<td>replace the value of an existing records</td>
</tr>

<tr>
<td>add</td>
<td>convinient method to update records</td>
</tr>

<tr>
<td>append</td>
<td>convinient method to update records</td>
</tr>

<tr>
<td>remove</td>
<td>remove records</td>
</tr>

<tr>
<td>create_table</td>
<td>create tables(dicts)</td>
</tr>

<tr>
<td>remove_table</td>
<td>remove tables(dicts)</td>
</tr>
</tbody>
</table>

<p><br>
And the following methods to retrieve data:</p>

<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>select</td>
<td>retreive one singe record</td>
</tr>

<tr>
<td>tables</td>
<td>retreive all tables from the object</td>
</tr>

<tr>
<td>keys</td>
<td>retreive all keys from tables</td>
</tr>
</tbody>
</table>

<h3 id="storing-data">Storing data</h3>

<p>Example illustrated in <code>iptyhon</code>. First declare the <code>Host</code> object.</p>

<pre><code class="language-ipython">In [1]: class Host:
   ...:         def __init__(self, hostname, ip, passwd, system, node, login_user):
   ...:                 self.hostname = hostname
   ...:                 self.ip = ip
   ...:                 self.login_user = login_user
   ...:                 self.password = passwd
   ...:                 self.system = system
   ...:                 self.node = node
   ...:

In [2]:     def __str__(self):
   ...:             return \
   ...:                 &quot;{0:s}\t=&gt;\t{1:&lt;15s}\t{2:&lt;20s}\t{3:&lt;20s}\t{4:&lt;7s}\t{5:&lt;7s}&quot;.format(
   ...:                     self.hostname, self.ip, self.login_user, 'password',
   ...:                     self.system, self.node)
   ...:
</code></pre>

<p>Import <code>SmallDB</code> and create a <code>db</code> object:</p>

<pre><code class="language-ipython">In [3]: from petitdb import SmallDB
In [4]: db = SmallDB('config.db')
</code></pre>

<p>Now we can create a table and store a <code>Host</code> object in it:</p>

<pre><code class="language-ipython">In [5]: db.create_table('HostsConfig')
In [6]: db.insert('HostsConfig', 'Hostname1', Host('Hostname1', '1.1.1.1', 'password1', 'system1', 'node1', 'root'))
</code></pre>

<p>You can see that the object have been stored by calling <code>db.print_db()</code>:</p>

<pre><code class="language-ipython">In [8]: db.print_db()
***************
* HostsConfig *
***************
key				data
-----------------------------------------------------------------
Hostname1				&lt;__main__.Host instance at 0x105945248&gt;
</code></pre>

<p>To persistently save the data on disk(in the shelve), we must call <code>db.print()</code>:</p>

<pre><code class="language-ipython">In [10]: db.save()
In [11]: db.close()
</code></pre>

<p>After closing, trying save data will initiate an error:</p>

<pre><code class="language-ipython">In [12]: db.save()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-12-0883b2e3c451&gt; in &lt;module&gt;()
----&gt; 1 db.save()
...
ValueError: invalid operation on closed shelf
</code></pre>

<p>I think I could improve the error handling here by watching the close status&hellip;
<br><br>
If you examine your filesystem, you can see that a config.db file was created</p>

<pre><code class="language-sh">➜  petitdb git:(master) ✗ ls -l config.db
-rw-r--r--  1 kemal  staff  16384 Mar 26 01:23 config.db
➜  petitdb git:(master) ✗ file config.db
config.db: Berkeley DB 1.85 (Hash, version 2, native byte-order)
</code></pre>

<h3 id="retreiving-data">Retreiving data</h3>

<p>If we go back and initialize a <code>db</code> object the same way we did before, the data will be read from <code>config.db</code>. The contents can be accessed easily with methods provided by <code>SmallDB</code>.
<br>
You can get a list of the tables:</p>

<pre><code class="language-ipython">In [4]: db = SmallDB('config.db')
In [9]: db.tables()
Out[9]: ['HostsConfig']
</code></pre>

<p>And also see the keys stored inside a table:</p>

<pre><code class="language-ipython">In [10]: db.keys('HostsConfig')
Out[10]: ['Hostname1']
</code></pre>

<p>And get the value with <code>db.select()</code></p>

<pre><code class="language-ipython">In [11]: h = db.select('HostsConfig', 'Hostname1')
In [14]: h.ip
Out[14]: '1.1.1.1'
In [16]: h.hostname
Out[16]: 'Hostname1'
</code></pre>

<p><br>
I&rsquo;ve mainly used this library to store complex configurations to use in some main scripts. It&rsquo;s a very lightweight solution to easily store and manage a small amount of data when writing python scripts.</p>

  </div>
</div>

      <footer>
        <hr>
        <small>
          &copy; 2022 .
          Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> using the <a href="https://github.com/arjunkrishnababu96/basics" target="_blank">Basics</a> theme.
        </small>
      </footer>
    </div> 

    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>

